/*
 * Copyright 2025 glomdom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Diagnostics.CodeAnalysis;
using BinaryWizard.Model;
using BinaryWizard.Segmenting;

namespace BinaryWizard;

[Generator]
public class Generator : IIncrementalGenerator {
    private readonly SyntaxTrivia _autogeneratedComment = SyntaxFactory.Comment("// <autogenerated/>");

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var assembly = Assembly.GetExecutingAssembly();
        var resourceNames = assembly.GetManifestResourceNames();

        context.RegisterPostInitializationOutput(ctx => {
            foreach (var resourceName in resourceNames) {
                using var stream = assembly.GetManifestResourceStream(resourceName);
                if (stream is null) continue;

                using var reader = new StreamReader(stream);
                var source = reader.ReadToEnd();

                var hintParts = Path.GetFileNameWithoutExtension(resourceName).Split('.');
                var hintName = hintParts[hintParts.Length - 1];

                ctx.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
            }
        });

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax or StructDeclarationSyntax,
                (ctx, _) => GetTypeDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        var sources = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(
            sources,
            (spc, t) => { GenerateCode(spc, t.Left, t.Right); }
        );
    }

    private static (TypeDeclarationSyntax, bool reportAttributeFound) GetTypeDeclarationForSourceGen(GeneratorSyntaxContext context) {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;

        foreach (var attributeSyntax in typeDeclaration.AttributeLists.SelectMany(list => list.Attributes)) {
            if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();
            if (attributeName == $"{Constants.Codegen.Namespace}.{Constants.Attributes.BinarySerializable}") return (typeDeclaration, true);
        }

        return (typeDeclaration, false);
    }

    private void GenerateCode(SourceProductionContext spc, Compilation compilation, ImmutableArray<TypeDeclarationSyntax> classDeclarations) {
        Debug.WriteLine("Starting code generation");

        foreach (var declarationSyntax in classDeclarations) {
            var semanticModel = compilation.GetSemanticModel(declarationSyntax.SyntaxTree);
            if (ModelExtensions.GetDeclaredSymbol(semanticModel, declarationSyntax) is not INamedTypeSymbol classSymbol) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var declarationName = declarationSyntax.Identifier.Text;

            var segmentManager = new SegmentManager();
            var method = CreateReadMethod(spc, segmentManager, semanticModel, classSymbol);

            Debug.WriteLine($"Created read method for {classSymbol.Name}");

            TypeDeclarationSyntax declaration = declarationSyntax is ClassDeclarationSyntax
                ? SyntaxFactory.ClassDeclaration(declarationName)
                : SyntaxFactory.StructDeclaration(declarationName);

            var clazz = declaration
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                .AddMembers(method);

            var ns = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(namespaceName))
                .AddMembers(clazz);

            var unit = SyntaxFactory.CompilationUnit()
                .AddUsings(
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("System")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("System.IO")),
                    SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("System.Buffers.Binary"))
                )
                .AddMembers(ns);

            var firstToken = unit.GetFirstToken();
            unit = unit.ReplaceToken(firstToken, firstToken.WithLeadingTrivia(SyntaxFactory.TriviaList(_autogeneratedComment, SyntaxFactory.CarriageReturnLineFeed)));

            var code = unit.NormalizeWhitespace().ToFullString();

            spc.AddSource($"BinarySerializable_{declarationName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private MethodDeclarationSyntax CreateReadMethod(SourceProductionContext spc, SegmentManager segmentManager, SemanticModel semantics, INamedTypeSymbol classSymbol) {
        var initializer = SyntaxFactory.ParseStatement($"var result = new {classSymbol.Name}();");
        var ret = SyntaxFactory.ParseStatement("return result;");

        var readStatements = BuildReadStatements(spc, segmentManager, semantics, classSymbol, "result").ToArray();
        var methodBlock = SyntaxFactory.Block()
            .AddStatements(initializer)
            .AddStatements(readStatements)
            .AddStatements(ret);

        var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(classSymbol.Name), "FromBinary")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword))
            .AddParameters(("reader", "System.IO.BinaryReader"))
            .WithBody(methodBlock);

        return method;
    }

    private IEnumerable<StatementSyntax> BuildReadStatements(SourceProductionContext spc,
        SegmentManager segmentManager,
        SemanticModel semantics,
        INamedTypeSymbol classSymbol,
        string outputName
    ) {
        var fields = classSymbol.GetMembers().OfType<IFieldSymbol>();

        foreach (var field in fields) {
            var fieldType = field.Type;

            if (IsPrimitiveLike(fieldType)) {
                var fieldDef = new FieldDef(field.Name, fieldType) {
                    ByteSize = GetByteSizeForPrimitive(fieldType),
                };

                segmentManager.AddField(fieldDef);
                DebugUtilities.CreatedFieldDef(fieldDef);
            } else if (IsArrayLike(fieldType, out var arrSymbol)) {
                if (arrSymbol.Rank != 1) throw new NotSupportedException("Arrays which have more than 1 dimension are not supported.");

                var binaryArrayAttr = field.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "BinaryArrayAttribute");
                if (binaryArrayAttr is null) {
                    ReportArrayIsMissingAttribute(spc, field);

                    yield break;
                }

                if (!AreAnyNamedArgsProvided(binaryArrayAttr, "Size", "SizeMember")) {
                    ReportArrayIsMissingSizeArgument(spc, field);

                    yield break;
                }

                if (AreAllNamedArgsProvided(binaryArrayAttr, "Size", "SizeMember")) {
                    ReportArrayHasConflictingSizeArguments(spc, field);

                    yield break;
                }

                var fieldDef = new FieldDef(field.Name, arrSymbol.ElementType);

                if (TryGetNamedArg(binaryArrayAttr, "Size", out var arrSize)) {
                    var arrSizeValue = (int)arrSize.Value!;
                    fieldDef.ByteSize = arrSizeValue * GetByteSizeForPrimitive(arrSymbol.ElementType);
                    fieldDef.TypeModel.FixedArraySize = arrSizeValue;
                    fieldDef.TypeModel.InnerType = arrSymbol.ElementType;
                    fieldDef.TypeModel.InnerTypeByteSize = GetByteSizeForPrimitive(arrSymbol.ElementType);
                } else if (TryGetNamedArg(binaryArrayAttr, "SizeMember", out var sizeMember)) {
                    // TODO: dynamic segments

                    var statements = GetReadStatementsForArrayWithMember(arrSymbol, outputName, field.Name, (string)sizeMember.Value!);

                    foreach (var statement in statements) {
                        yield return statement;
                    }
                }

                DebugUtilities.CreatedFieldDef(fieldDef);

                segmentManager.AddField(fieldDef);
            } else if (HasBinarySerializableAttribute(fieldType)) {
                // TODO: maybe implement segmenting for nested reading? unsure of how to implement yet

                yield return SyntaxFactory.ParseStatement($"{outputName}.{field.Name} = {fieldType.Name}.FromBinary(reader);");

                Debug.WriteLine("Built statements for nested object");
            } else {
                ReportUnmarkedSerializableForField(spc, field);

                yield break;
            }
        }

        var segments = segmentManager.Commit();

        foreach (var seg in segments) {
            if (seg is not FixedSegment fixedSegment) continue;

            yield return SyntaxFactory.ParseStatement($"Span<byte> buf = stackalloc byte[{fixedSegment.Bytes}];");
            yield return SyntaxFactory.ParseStatement($"var __bytes_read = reader.Read(buf);");
            yield return SyntaxFactory.ParseStatement($"if (__bytes_read < {fixedSegment.Bytes}) throw new EndOfStreamException();");

            var offsetInBytes = 0;
            foreach (var field in fixedSegment.Fields) {
                if (field.TypeModel.IsArray) {
                    var elementBytes = GetByteSizeForPrimitive(field.TypeModel.InnerType!);

                    yield return SyntaxFactory.ParseStatement($"result.{field.Name} = new {field.TypeModel.Type}[{field.TypeModel.FixedArraySize!.Value}];");
                    yield return SyntaxFactory.ParseStatement(
                        $"for (var i = 0; i < {field.TypeModel.FixedArraySize}; i++)" + " " +
                        $"result.{field.Name}[i] = {GetBinaryPrimitiveReaderForPrimitive(field.TypeModel.Type)}(buf.Slice({offsetInBytes} + ({elementBytes} * i), {elementBytes}));"
                    );

                    offsetInBytes += field.TypeModel.FixedArraySize!.Value;

                    continue;
                }

                yield return SyntaxFactory.ParseStatement(
                    $"result.{field.Name} = {GetBinaryPrimitiveReaderForPrimitive(field.TypeModel.Type)}(buf.Slice({offsetInBytes}, {field.ByteSize}));"
                );

                offsetInBytes += field.ByteSize;
            }

            yield break;
        }

        segmentManager.Clear();
    }

    // TODO: Context is required if we want to support endianness.
    private string GetBinaryPrimitiveReaderForPrimitive(ITypeSymbol sym) {
        return sym.SpecialType switch {
            SpecialType.System_Int32 => "BinaryPrimitives.ReadInt32LittleEndian",

            _ => throw new InvalidOperationException(
                $"Unexpected type {sym.SpecialType} occurred in GetBinaryPrimitiveReaderForPrimitive"
            ),
        };
    }

    private IEnumerable<StatementSyntax> GetReadStatementsForArrayWithMember(
        IArrayTypeSymbol fieldType,
        string outName,
        string fieldName,
        string memberName
    ) {
        Debug.WriteLine("Building statements for array with size variable");

        var elemType = fieldType.ElementType;

        if (IsPrimitiveLike(elemType)) {
            yield return SyntaxFactory.ParseStatement(
                $"for (var i = 0; i < {outName}.{memberName}; i++) {outName}.{fieldName}[i] = reader.{GetReadMethodNameForPrimitive(elemType)}();");

            yield break;
        }

        if (HasBinarySerializableAttribute(elemType)) {
            yield return SyntaxFactory.ParseStatement($"for (var i = 0; i < {outName}.{memberName}; i++) {outName}.{fieldName}[i] = {elemType.Name}.FromBinary(reader);");

            yield break;
        }

        // idk what to do here, still don't know if we can reach this
        throw new NotSupportedException($"Failed to create read statements for `{elemType}`");
    }

    private static TypedConstant OneArgOfMany(AttributeData data, params string[] args) {
        return args
                   .Select(arg => GetNamedArg(data, arg))
                   .FirstOrDefault(r => r is not null) ??
               throw new Exception($"Expected one of {string.Join(" or ", args)} to exist");
    }

    private static bool HasBinarySerializableAttribute(ITypeSymbol sym) => HasAttribute(sym, "BinarySerializableAttribute");
    private static bool HasAttribute(ITypeSymbol sym, string attrName) => sym.GetAttributes().Any(a => a.AttributeClass?.Name == attrName);

    private int GetByteSizeForPrimitive(ITypeSymbol primitive) {
        return primitive.SpecialType switch {
            SpecialType.System_Boolean => 1,
            SpecialType.System_Char => 1,
            SpecialType.System_SByte => 1,
            SpecialType.System_Byte => 1,
            SpecialType.System_Int16 => 2,
            SpecialType.System_UInt16 => 2,
            SpecialType.System_Int32 => 4,
            SpecialType.System_UInt32 => 4,
            SpecialType.System_Int64 => 8,
            SpecialType.System_UInt64 => 8,
            SpecialType.System_Decimal => 16,
            SpecialType.System_Double => 32,

            _ => throw new InvalidOperationException("Unexpected case encountered."),
        };
    }

    private string GetReadMethodNameForPrimitive(ITypeSymbol primitive) {
        return primitive.SpecialType switch {
            SpecialType.System_Boolean => "ReadBoolean",
            SpecialType.System_Char => "ReadChar",
            SpecialType.System_SByte => "ReadSByte",
            SpecialType.System_Byte => "ReadByte",
            SpecialType.System_Int16 => "ReadInt16",
            SpecialType.System_UInt16 => "ReadUInt16",
            SpecialType.System_Int32 => "ReadInt32",
            SpecialType.System_UInt32 => "ReadUInt32",
            SpecialType.System_Int64 => "ReadInt64",
            SpecialType.System_UInt64 => "ReadUInt64",
            SpecialType.System_Decimal => "ReadDecimal",
            SpecialType.System_Double => "ReadDouble",
            SpecialType.System_String => "ReadString",

            _ => throw new InvalidOperationException("Unexpected case encountered."),
        };
    }

    private static bool IsPrimitiveLike(ITypeSymbol symbol) {
        return symbol.SpecialType switch {
            SpecialType.System_Boolean or
                SpecialType.System_Byte or
                SpecialType.System_SByte or
                SpecialType.System_Int16 or
                SpecialType.System_UInt16 or
                SpecialType.System_Int32 or
                SpecialType.System_UInt32 or
                SpecialType.System_Int64 or
                SpecialType.System_UInt64 or
                SpecialType.System_Single or
                SpecialType.System_Double or
                SpecialType.System_Char or
                SpecialType.System_String or
                SpecialType.System_Decimal => true,

            _ => false,
        };
    }

    private static bool IsArrayLike(ITypeSymbol symbol, [NotNullWhen(true)] out IArrayTypeSymbol? arraySymbol) {
        if (symbol is IArrayTypeSymbol arr) {
            arraySymbol = arr;

            return true;
        }

        arraySymbol = null;

        return false;
    }

    private static bool AreAllNamedArgsProvided(AttributeData attr, params string[] names) {
        return attr.NamedArguments.Length != 0 && names.Select(name => attr.NamedArguments.Any(pair => pair.Key == name)).All(found => found);
    }

    private static bool AreAnyNamedArgsProvided(AttributeData attr, params string[] names) {
        return attr.NamedArguments.Length != 0 && names.Any(name => attr.NamedArguments.Any(pair => pair.Key == name));
    }

    private static TypedConstant? GetNamedArg(AttributeData attr, string name) {
        foreach (var pair in attr.NamedArguments.Where(pair => pair.Key == name)) {
            return pair.Value;
        }

        return null;
    }

    private static bool TryGetNamedArg(
        AttributeData attr,
        string name,
        out TypedConstant typedConstant
    ) {
        foreach (var pair in attr.NamedArguments.Where(pair => pair.Key == name)) {
            typedConstant = pair.Value;

            return true;
        }

        typedConstant = default;

        return false;
    }

    private void ReportArrayHasConflictingSizeArguments(SourceProductionContext spc, IFieldSymbol field) {
        var location = GetVariableDeclaratorNameLocation(field);

        spc.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.ArrayHasConflictingSizeArguments,
            location,
            field.Name
        ));
    }

    private void ReportArrayIsMissingSizeArgument(SourceProductionContext spc, IFieldSymbol field) {
        var location = GetVariableDeclaratorNameLocation(field);

        spc.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.MarkedArraylikeHasNoSizeOrSizeProviderRule,
            location,
            field.Name
        ));
    }

    private void ReportArrayIsMissingAttribute(SourceProductionContext spc, IFieldSymbol field) {
        var location = GetVariableDeclaratorNameLocation(field);

        spc.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.ArrayHasNoBinaryArrayAttributeRule,
            location,
            field.Name
        ));
    }

    private void ReportUnmarkedSerializableForField(SourceProductionContext spc, IFieldSymbol field) {
        var location = GetVariableDeclaratorLocation(field);

        spc.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.MissingBinarySerializableAttributeRule,
            location,
            field.Type.Name
        ));
    }

    private Location GetVariableDeclaratorLocation(IFieldSymbol field) {
        var fieldSyntaxRef = field.DeclaringSyntaxReferences.FirstOrDefault();

        var fieldSyntax = fieldSyntaxRef?.GetSyntax() as VariableDeclaratorSyntax;
        if (fieldSyntax?.Parent is not VariableDeclarationSyntax varDecl) throw new Exception("Field parent is not a variable declaration.");

        var location = varDecl.Type.GetLocation();

        return location;
    }

    private Location GetVariableDeclaratorNameLocation(IFieldSymbol field) {
        var fieldSyntaxRef = field.DeclaringSyntaxReferences.FirstOrDefault();
        if (fieldSyntaxRef is null) throw new Exception("No syntax reference found for field.");

        return fieldSyntaxRef.GetSyntax() is not VariableDeclaratorSyntax fieldSyntax
            ? throw new Exception("Field syntax is not a VariableDeclaratorSyntax.")
            : fieldSyntax.Identifier.GetLocation();
    }
}