/*
 * Copyright 2025 glomdom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace BinaryWizard;

[Generator]
public class Generator : IIncrementalGenerator {
    private const string Namespace = "BinaryWizard.Generated";
    private const string AttributeName = "BinaryStruct";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace} {{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeName} : System.Attribute {{ }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "BinaryWizardAttributes.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        var sources = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(
            sources,
            ((spc, t) => GenerateCode(spc, t.Left, t.Right))
        );
    }

    private static (ClassDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context) {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes) {
            if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName == $"{Namespace}.{AttributeName}") return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations) {
        foreach (var classDeclarationSyntax in classDeclarations) {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax) is not INamedTypeSymbol classSymbol) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;

            var method = CreateReadMethod(semanticModel, classSymbol);

            var clazz = SyntaxFactory.ClassDeclaration(className)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                .AddMembers(method);

            var ns = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(namespaceName))
                .AddMembers(clazz);

            var code = ns.NormalizeWhitespace().ToFullString();

            context.AddSource($"BinaryStruct_{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private MethodDeclarationSyntax CreateReadMethod(SemanticModel semantics, INamedTypeSymbol classSymbol) {
        var initializer = SyntaxFactory.ParseStatement($"var result = new {classSymbol.Name}();");
        var ret = SyntaxFactory.ParseStatement("return result;");

        var readStatements = BuildReadStatements(semantics, classSymbol, "result").ToArray();
        var methodBlock = SyntaxFactory.Block()
            .AddStatements(initializer)
            .AddStatements(readStatements)
            .AddStatements(ret);

        var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(classSymbol.Name), "FromBinary")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword))
            .AddParameters(("reader", "System.IO.BinaryReader"))
            .WithBody(methodBlock);

        return method;
    }

    private IEnumerable<StatementSyntax> BuildReadStatements(SemanticModel semantics, INamedTypeSymbol classSymbol, string outputName) {
        var fields = classSymbol.GetMembers().OfType<IFieldSymbol>();

        foreach (var field in fields) {
            var method = GetReadMethodNameForPrimitive(semantics, field.Type);

            yield return SyntaxFactory.ParseStatement($"{outputName}.{field.Name} = reader.{method}();");
        }
    }

    private string GetReadMethodNameForPrimitive(SemanticModel semantics, ITypeSymbol primitive) {
        return (primitive.SpecialType) switch {
            SpecialType.System_Boolean => "ReadBoolean",
            SpecialType.System_Char => "ReadChar",
            SpecialType.System_SByte => "ReadSByte",
            SpecialType.System_Byte => "ReadByte",
            SpecialType.System_Int16 => "ReadInt16",
            SpecialType.System_UInt16 => "ReadUInt16",
            SpecialType.System_Int32 => "ReadInt32",
            SpecialType.System_UInt32 => "ReadUInt32",
            SpecialType.System_Int64 => "ReadInt32",
            SpecialType.System_UInt64 => "ReadUInt62",
            SpecialType.System_Decimal => "ReadDecimal",
            SpecialType.System_Double => "ReadDouble",

            _ => throw new NotSupportedException("Non-primitives are not supported yet."),
        };
    }
}