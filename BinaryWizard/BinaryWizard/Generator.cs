/*
 * Copyright 2025 glomdom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Diagnostics.CodeAnalysis;

namespace BinaryWizard;

[Generator]
public class Generator : IIncrementalGenerator {
    private SourceProductionContext _spc;

    private readonly SyntaxTrivia _autogeneratedComment = SyntaxFactory.Comment("// <autogenerated/>");

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var assembly = Assembly.GetExecutingAssembly();
        var resourceNames = assembly.GetManifestResourceNames();

        context.RegisterPostInitializationOutput(ctx => {
            foreach (var resourceName in resourceNames) {
                using var stream = assembly.GetManifestResourceStream(resourceName);
                if (stream is null) continue;

                using var reader = new StreamReader(stream);
                var source = reader.ReadToEnd();

                var hintParts = Path.GetFileNameWithoutExtension(resourceName).Split('.');
                var hintName = hintParts[hintParts.Length - 1];

                ctx.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
            }
        });

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        var sources = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(
            sources,
            ((spc, t) => {
                _spc = spc;

                GenerateCode(t.Left, t.Right);
            })
        );
    }

    private static (ClassDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context) {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeSyntax in classDeclarationSyntax.AttributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes)) {
            if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();
            if (attributeName == $"{Constants.Codegen.Namespace}.{Constants.Attributes.BinarySerializable}") return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    private void GenerateCode(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations) {
        foreach (var classDeclarationSyntax in classDeclarations) {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax) is not INamedTypeSymbol classSymbol) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;

            var method = CreateReadMethod(semanticModel, classSymbol);

            var clazz = SyntaxFactory.ClassDeclaration(className)
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
                .AddMembers(method);

            var ns = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.IdentifierName(namespaceName))
                .AddMembers(clazz);

            var unit = SyntaxFactory.CompilationUnit()
                .AddMembers(ns);

            var firstToken = unit.GetFirstToken();
            unit = unit.ReplaceToken(firstToken, firstToken.WithLeadingTrivia(SyntaxFactory.TriviaList(_autogeneratedComment, SyntaxFactory.CarriageReturnLineFeed)));

            var code = unit.NormalizeWhitespace().ToFullString();

            _spc.AddSource($"BinarySerializable_{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private MethodDeclarationSyntax CreateReadMethod(SemanticModel semantics, INamedTypeSymbol classSymbol) {
        var initializer = SyntaxFactory.ParseStatement($"var result = new {classSymbol.Name}();");
        var ret = SyntaxFactory.ParseStatement("return result;");

        var readStatements = BuildReadStatements(semantics, classSymbol, "result").ToArray();
        var methodBlock = SyntaxFactory.Block()
            .AddStatements(initializer)
            .AddStatements(readStatements)
            .AddStatements(ret);

        var method = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(classSymbol.Name), "FromBinary")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.StaticKeyword))
            .AddParameters(("reader", "System.IO.BinaryReader"))
            .WithBody(methodBlock);

        return method;
    }

    private IEnumerable<StatementSyntax> BuildReadStatements(SemanticModel semantics, INamedTypeSymbol classSymbol, string outputName) {
        var fields = classSymbol.GetMembers().OfType<IFieldSymbol>();

        foreach (var field in fields) {
            var fieldType = field.Type;

            if (IsPrimitiveLike(fieldType)) {
                var method = GetReadMethodNameForPrimitive(fieldType);

                yield return SyntaxFactory.ParseStatement($"{outputName}.{field.Name} = reader.{method}();");
            } else {
                if (IsArrayLike(fieldType, out var arrSymbol)) {
                    if (arrSymbol.Rank != 1) throw new NotSupportedException("Arrays which have more than 1 dimension are not supported.");

                    var binaryArrayAttr = field.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "BinaryArrayAttribute");
                    if (binaryArrayAttr is null || !TryGetNamedArg(binaryArrayAttr, "Size", out var arrSize)) {
                        ReportArraylikeMissingConstSize(field);

                        yield break;
                    }

                    var statements = GetReadStatementsForArray(semantics, arrSymbol, outputName, field.Name, (int)arrSize.Value!);

                    foreach (var statement in statements) {
                        yield return statement;
                    }

                    continue;
                }

                if (HasBinarySerializableAttribute(fieldType)) {
                    yield return SyntaxFactory.ParseStatement($"{outputName}.{field.Name} = {fieldType.Name}.FromBinary(reader);");
                } else {
                    ReportUnmarkedSerializableForField(field);

                    yield break;
                }
            }
        }
    }

    private IEnumerable<StatementSyntax> GetReadStatementsForArray(SemanticModel semantics, IArrayTypeSymbol fieldType, string outName, string fieldName, int arrSize) {
        var elemType = fieldType.ElementType;

        if (elemType.SpecialType == SpecialType.System_Byte) {
            // little optimization for bytes

            yield return SyntaxFactory.ParseStatement($"{outName}.{fieldName} = reader.ReadBytes({arrSize});");

            yield break;
        } else if (IsPrimitiveLike(elemType)) {
            yield return SyntaxFactory.ParseStatement($"for (var i = 0; i < {arrSize}; i++) {outName}.{fieldName}[i] = reader.{GetReadMethodNameForPrimitive(elemType)}();");

            yield break;
        } else {
            if (HasBinarySerializableAttribute(elemType)) {
                yield return SyntaxFactory.ParseStatement($"for (var i = 0; i < {arrSize}; i++) {outName}.{fieldName}[i] = {elemType.Name}.FromBinary(reader);");

                yield break;
            }
        }

        // idk what to do here, still don't know if we can reach this
        throw new NotSupportedException($"Failed to create read statements for `{elemType}`");
    }

    private static bool HasBinarySerializableAttribute(ITypeSymbol sym) => HasAttribute(sym, "BinarySerializableAttribute");
    private static bool HasAttribute(ITypeSymbol sym, string attrName) => sym.GetAttributes().Any(a => a.AttributeClass?.Name == attrName);

    private string GetReadMethodNameForPrimitive(ITypeSymbol primitive) {
        return (primitive.SpecialType) switch {
            SpecialType.System_Boolean => "ReadBoolean",
            SpecialType.System_Char => "ReadChar",
            SpecialType.System_SByte => "ReadSByte",
            SpecialType.System_Byte => "ReadByte",
            SpecialType.System_Int16 => "ReadInt16",
            SpecialType.System_UInt16 => "ReadUInt16",
            SpecialType.System_Int32 => "ReadInt32",
            SpecialType.System_UInt32 => "ReadUInt32",
            SpecialType.System_Int64 => "ReadInt32",
            SpecialType.System_UInt64 => "ReadUInt62",
            SpecialType.System_Decimal => "ReadDecimal",
            SpecialType.System_Double => "ReadDouble",
            SpecialType.System_String => "ReadString",

            _ => throw new InvalidOperationException("Unexpected case encountered."),
        };
    }

    private static bool IsPrimitiveLike(ITypeSymbol symbol) {
        return symbol.SpecialType switch {
            SpecialType.System_Boolean or
                SpecialType.System_Byte or
                SpecialType.System_SByte or
                SpecialType.System_Int16 or
                SpecialType.System_UInt16 or
                SpecialType.System_Int32 or
                SpecialType.System_UInt32 or
                SpecialType.System_Int64 or
                SpecialType.System_UInt64 or
                SpecialType.System_Single or
                SpecialType.System_Double or
                SpecialType.System_Char or
                SpecialType.System_String or
                SpecialType.System_Decimal => true,

            _ => false,
        };
    }

    private static bool IsArrayLike(ITypeSymbol symbol, [NotNullWhen(true)] out IArrayTypeSymbol? arraySymbol) {
        if (symbol is IArrayTypeSymbol arr) {
            arraySymbol = arr;

            return true;
        }

        arraySymbol = null;

        return false;
    }

    private static bool TryGetNamedArg(
        AttributeData attr,
        string name,
        out TypedConstant typedConstant
    ) {
        foreach (var pair in attr.NamedArguments.Where(pair => pair.Key == name)) {
            typedConstant = pair.Value;

            return true;
        }

        typedConstant = default;

        return false;
    }

    private void ReportArraylikeMissingConstSize(IFieldSymbol field) {
        var location = GetVariableDeclaratorNameLocation(field);

        _spc.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.ArraylikeHasNoConstCapacityRule,
            location,
            field.Name
        ));
    }

    private void ReportUnmarkedSerializableForField(IFieldSymbol field) {
        var location = GetVariableDeclaratorLocation(field);

        _spc.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.MissingBinarySerializableAttributeRule,
            location,
            field.Type.Name
        ));
    }

    private Location GetVariableDeclaratorLocation(IFieldSymbol field) {
        var fieldSyntaxRef = field.DeclaringSyntaxReferences.FirstOrDefault();

        var fieldSyntax = fieldSyntaxRef?.GetSyntax() as VariableDeclaratorSyntax;
        if (fieldSyntax?.Parent is not VariableDeclarationSyntax varDecl) throw new Exception("Field parent is not a variable declaration.");

        var location = varDecl.Type.GetLocation();

        return location;
    }

    private Location GetVariableDeclaratorNameLocation(IFieldSymbol field) {
        var fieldSyntaxRef = field.DeclaringSyntaxReferences.FirstOrDefault();
        if (fieldSyntaxRef is null) throw new Exception("No syntax reference found for field.");

        return fieldSyntaxRef.GetSyntax() is not VariableDeclaratorSyntax fieldSyntax
            ? throw new Exception("Field syntax is not a VariableDeclaratorSyntax.")
            : fieldSyntax.Identifier.GetLocation();
    }

}